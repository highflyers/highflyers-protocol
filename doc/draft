Zserializowane dane:
[0] - typ struktury
[1..2] - flaga dostêpnoœci zmiennych
[3..size-6] - dane (size - rozmiar pakietu, trzeba wyliczyæ rêcznie na podstawie koñca ramki)
[size-5..size-2] - crc32
[size-1] - znak koñca ramki

Ograniczenia:
Mo¿na zatem zdefiniowaæ 128 typów struktur (jeœli bêdzie potrzeba, rozszerzy siê na 2 bajty, ale w¹tpie). Pierwszy bit to endianizm: 0-little, 1-big (dla tego tylko 128 typów struktur).
Maksymalna liczba zmiennych w strukturze to 16, ale te¿ mo¿na rozszerzyæ (byæ mo¿e dobrze by by³o zrobiæ to jakoœ flexi) albo doprecyzowaæ, ¿e 16 tyczy siê tylko pól opcjonalnych, a zwyk³ych pól mo¿e byæ wiele wiêcej.
Maksymalny rozmiar pakietu: 2^16 - tego raczej nie przekroczymy, wiêc nie ma siê co martwiæ.


Zdeserializowane dane:
struct ExampleStruct
{
	int32 Val1;
	boost::optional<double> Val2; // w C# - Nullable, w ansi c te¿ jakoœ trzeba bêdzie to rozwi¹zaæ
	OtherStruct Val3;
	byte Val4;
	double Val5;
};


Pliki .hfproto z opisem protoko³u:
Enumeracje:
enum SampleEnum
{
	ENUM_VAL1
	ENUM_VAL2
	ENUM_VAL3
	...
	ENUM_VAL256
}
Maksymalnie 256 wartoœci, jeœli bêdzie potrzeba (w co w¹tpie), mo¿na rozszerzyæ rozmiar enuma na 2 bajty

Struktury:
struct ExampleStruct
{
	int Val1
	double? Val2;
	OtherStruct Val3;
	byte Val4;
	double Val5;
};
'?' oznacza wartoœæ opcjonaln¹
Struktura OtherStruct musi byæ zdefiniowana przed ExampleStruct.


Przyk³adowy kod w C++:

byte data[] = {...};

// fill 'data' array here

try
{
	std::shared_ptr<Frame> frame(FrameBuilder::build_frame(data));
	new_frame_received(frame);
}
catch(const std::exception& ex)
{
	cerr << "somethings wrong with your data;/ can't parse it!" << endl;
}

// ... far far away
void on_new_telemetry_received(std::shared_ptr<Frame> frame)
{
	if (frame->get_type() != FrameTypes::TELEMETRY)
	   return;
	   
	std::shared_ptr<TelemetryFrame> tele_frame = std::static_pointer_cast<TelemetryFrame>(frame);
						     //alternative:  = frame->asTelemetryFrame();

	// do sth. with data
	cout << tele_frame->speed << endl;
}
	
